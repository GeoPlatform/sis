package org.apache.sis.internal.jaxb;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlElements;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchema;
import javax.xml.bind.annotation.XmlType;

import org.reflections.Configuration;
import org.reflections.Reflections;
import org.reflections.scanners.FieldAnnotationsScanner;
import org.reflections.scanners.MethodAnnotationsScanner;
import org.reflections.scanners.SubTypesScanner;
import org.reflections.scanners.TypeAnnotationsScanner;
import org.reflections.util.ClasspathHelper;
import org.reflections.util.ConfigurationBuilder;
import org.reflections.util.FilterBuilder;

/**
 * This class is used to read through the classes in the org.apache.sis.metadata.iso package
 * and create a text file containing a list of XML elements paired with the ISO 19115-3 namespace
 * each element is a part of.
 * 
 * To do this, Java's reflection capabilities are used.
 * 
 * The list is written to {@code src/main/resources/org/apache/sis/internal/jaxb/ElementNamespaceMap.txt}
 * 
 * IMPORTANT NOTE: {@link FilteredStreamReader} uses the file generated by this class, but it cannot access it without
 * creating circular import situation. As a result, the file generated at the location above must be
 * manually copied into the sis-utility project at the same location.
 * 
 * @author Cullen Rombach (Image Matters)
 * @since 0.8
 * @version 0.8
 */
@SuppressWarnings({"rawtypes", "unchecked"})
public class ElementNamespaceMapWriter {

	/**
	 * Key: element name
	 * Value: associated namespace
	 */
	private static Map<String, String> elementNamespaceMap;

	private static final String MAP_PATH = "src/main/resources/org/apache/sis/internal/jaxb/ElementNamespaceMap.txt";
	private static final File MAP_FILE = new File(MAP_PATH);

	/**
	 * Write a map of element and namespace pairs used in ISO 19115-3.
	 * 
	 * @return Map where each key is an element name and each value is the corresponding namespace
	 * @throws ClassNotFoundException
	 */
	public static Map<String, String> getElementNamespaceMap() throws ClassNotFoundException {
		// Initialize the map.
		elementNamespaceMap = new TreeMap<String,String>();

		// Instantiate Reflections object for scanning classes in org.apache.sis.metadata.iso and org.apache.sis.internal.jaxb
		Configuration isoConfig = new ConfigurationBuilder()
				.setScanners(new SubTypesScanner(false), new TypeAnnotationsScanner(), new MethodAnnotationsScanner(), new FieldAnnotationsScanner())
				.setUrls(ClasspathHelper.forPackage("org.apache.sis"))
				.filterInputsBy(new FilterBuilder().includePackage("org.apache.sis.metadata.iso").includePackage("org.apache.sis.util.iso").includePackage("org.apache.sis.internal.jaxb"));
		Reflections reflections = new Reflections(isoConfig);

		mapElements(reflections);

		return elementNamespaceMap;
	}

	/**
	 * Map the elements in the package specified by the given Reflections object.
	 * @param reflections
	 * @throws ClassNotFoundException
	 */
	private static void mapElements(Reflections reflections) throws ClassNotFoundException {
		// Loop through all the classes in org.apache.sis.metadata.iso with @XmlRootElement annotation.
		// This should cover all the classes that are used
		for(Class clazz : reflections.getTypesAnnotatedWith(XmlRootElement.class)) {
			XmlRootElement rootElement = (XmlRootElement) clazz.getAnnotation(XmlRootElement.class);
			if(rootElement != null) {
				// If the found namespace is "##default", replace it.
				String namespace = rootElement.namespace();
				if(namespace.equals("##default")) {
					namespace = findBestNamespace(clazz);
				}

				// Find the name of the element.
				String name = rootElement.name();
				// If the found name is "##default", replace it.
				if(name.equals("##default")) {
					name = clazz.getSimpleName();
				}
				// Append "|" to name for ease of reading in FilteredStreamReader.
				name += "|";

				// Store the name + namespace combination as a key/value pair.
				elementNamespaceMap.put(name, namespace);
			}
		}

		// Loop through all methods annotated with @XmlElement.
		for(Method method : reflections.getMethodsAnnotatedWith(XmlElement.class)) {
			XmlElement element = (XmlElement) method.getAnnotation(XmlElement.class);
			if(element != null) {
				// Replace all "##default" namespaces with the namespace in the
				// package-info.java file in the method's package.
				String namespace = element.namespace();
				if(namespace.equals("##default")) {
					namespace = findBestNamespace(method);
				}

				// Get the name of the method.
				String name = element.name();
				// If the found name is "##default", replace it.
				if(name.equals("##default")) {
					name = method.getName();
				}
				// Append "|" to name for ease of reading in FilteredStreamReader.
				name += "|";

				// Add the declaring class to the name for distinguishing between elements with the same name.
				Class declaringClass = method.getDeclaringClass();
				XmlRootElement rootElement = (XmlRootElement) declaringClass.getAnnotation(XmlRootElement.class);
				if(rootElement != null && rootElement.name() != null) {
					name += rootElement.name();
				}
				// This situation can occur in wrapper classes.
				else if(declaringClass.getSimpleName().equals("Wrapper") && declaringClass.getEnclosingClass() != null) {
					name += declaringClass.getEnclosingClass().getSimpleName();
				}

				// Store the name + namespace combination as a key/value pair.
				elementNamespaceMap.put(name, namespace);

				// Also need to put another copy of the name-namespace pairing into the map for each
				// subclass of the declaring class.
				Set<Class> subClasses = reflections.getSubTypesOf(declaringClass);
				if(subClasses != null) {
					for(Class subClass : subClasses) {
						XmlRootElement root = (XmlRootElement) subClass.getAnnotation(XmlRootElement.class);
						if(root != null) {
							// Use the namespace of the original method declartion.
							String newName = name.substring(0, name.indexOf("|") + 1) + root.name();
							elementNamespaceMap.put(newName, findBestNamespace(method));
						}
					}
				}
			}
		}

		// Loop through all fields annotated with @XmlElement.
		for(Field field : reflections.getFieldsAnnotatedWith(XmlElement.class)) {
			XmlElement element = (XmlElement) field.getAnnotation(XmlElement.class);
			if(element != null) {
				// Replace all "##default" namespaces with the namespace in the
				// package-info.java file in the method's package.
				String namespace = element.namespace();
				if(namespace.equals("##default")) {
					namespace = findBestNamespace(field);
				}

				// Get the name of the element.
				String name = element.name();
				// Fix the name if it is "##default".
				if(name.equals("##default")) {
					name = field.getName();
				}
				// Append "|" to name for ease of reading in FilteredStreamReader.
				name += "|";

				// Add the declaring class to the name for distinguishing between elements with the same name.
				Class declaringClass = field.getDeclaringClass();
				XmlRootElement rootElement = (XmlRootElement) declaringClass.getAnnotation(XmlRootElement.class);
				if(rootElement != null && rootElement.name() != null && !(rootElement.name().equals("##default"))) {
					name += rootElement.name();
				}
				// This situation can occur in wrapper classes.
				else if(declaringClass.getSimpleName().equals("Wrapper") && declaringClass.getEnclosingClass() != null) {
					name += declaringClass.getEnclosingClass().getSimpleName();
				}
				// If the parent class does not have a root element annotation, it might be a wrapper. Check if that is the case.
				// If it is, add the wrapper at this element's parent.
				else if(field.getAnnotation(XmlElementWrapper.class) != null) {
					XmlElementWrapper wrapper = field.getAnnotation(XmlElementWrapper.class);
					name += wrapper.name();
				}

				// Store the name + namespace combination as a key/value pair.
				elementNamespaceMap.put(name, namespace);
			}
		}

		// Loop through all fields annotated with @XmlElements.
		for(Field field : reflections.getFieldsAnnotatedWith(XmlElements.class)) {
			XmlElements elements = (XmlElements) field.getAnnotation(XmlElements.class);
			if(elements != null) {
				for(XmlElement element : elements.value()) {
					// Replace all "##default" namespaces with the namespace in the
					// package-info.java file in the method's package.
					String namespace = element.namespace();
					if(namespace.equals("##default")) {
						namespace = findBestNamespace(field);
					}

					// Get the name of the element.
					String name = element.name();
					// Fix the name if it is "##default".
					if(name.equals("##default")) {
						name = field.getName();
					}
					// Append "|" to name for ease of reading in FilteredStreamReader.
					name += "|";

					// Add the declaring class to the name for distinguishing between elements with the same name.
					Class declaringClass = field.getDeclaringClass();
					XmlRootElement rootElement = (XmlRootElement) declaringClass.getAnnotation(XmlRootElement.class);
					if(rootElement != null && rootElement.name() != null && !(rootElement.name().equals("##default"))) {
						name += rootElement.name();
					}
					// This situation can occur in wrapper classes.
					else if(declaringClass.getSimpleName().equals("Wrapper") && declaringClass.getEnclosingClass() != null) {
						name += declaringClass.getEnclosingClass().getSimpleName();
					}

					// Store the name + namespace combination as a key/value pair.
					elementNamespaceMap.put(name, namespace);
				}
			}
		}

		// Loop through all fields annotated with @XmlElementWrapper.
		for(Field field : reflections.getFieldsAnnotatedWith(XmlElementWrapper.class)) {
			XmlElementWrapper element = (XmlElementWrapper) field.getAnnotation(XmlElementWrapper.class);
			if(element != null) {
				// Replace all "##default" namespaces with the namespace in the
				// package-info.java file in the method's package.
				String namespace = element.namespace();
				if(namespace.equals("##default")) {
					namespace = findBestNamespace(field);
				}

				// Get the name of the element.
				String name = element.name();
				// Fix the name if it is "##default".
				if(name.equals("##default")) {
					name = field.getName();
				}
				// Append "|" to name for ease of reading in FilteredStreamReader.
				name += "|";

				// Add the declaring class to the name for distinguishing between elements with the same name.
				Class declaringClass = field.getDeclaringClass();
				XmlRootElement rootElement = (XmlRootElement) declaringClass.getAnnotation(XmlRootElement.class);
				if(rootElement != null && rootElement.name() != null && !(rootElement.name().equals("##default"))) {
					name += rootElement.name();
				}
				// This situation can occur in wrapper classes.
				else if(declaringClass.getSimpleName().equals("Wrapper") && declaringClass.getEnclosingClass() != null) {
					name += declaringClass.getEnclosingClass().getSimpleName();
				}

				// Store the name + namespace combination as a key/value pair.
				elementNamespaceMap.put(name, namespace);
			}
		}
	}

	/**
	 * Return the best namespace found for the given Class object.
	 * @param clazz
	 * @return namespace as a string.
	 * @throws ClassNotFoundException 
	 */
	private static String findBestNamespace(Class clazz) throws ClassNotFoundException {
		// Look in the package-info.java file in the class's package.
		String qualifiedName = getPackageName(clazz) + ".package-info";
		Class packageInfo = Class.forName(qualifiedName);
		XmlSchema schema = (XmlSchema) packageInfo.getAnnotation(XmlSchema.class);
		return schema.namespace();
	}

	/**
	 * Return the best namespace found for the given Method object.
	 * @param method
	 * @return namespace as a string.
	 * @throws ClassNotFoundException 
	 */
	private static String findBestNamespace(Method method) throws ClassNotFoundException {
		// First, see if the declaring class is already in the map (i.e. it is annotated with @XmlElement).
		Class declaringClass = method.getDeclaringClass();
		XmlRootElement rootElement = (XmlRootElement) declaringClass.getAnnotation(XmlRootElement.class);
		if(rootElement != null && rootElement.name() != null) {
			return elementNamespaceMap.get(rootElement.name() + "|");
		}

		// Next, look to see if the containing class has been annotated with @XmlType.
		XmlType xmlType = (XmlType) declaringClass.getAnnotation(XmlType.class);
		if(xmlType != null && !(xmlType.namespace().equals("##default"))) {
			return xmlType.namespace();
		}

		// Finally, look in the package-info.java file in the declaring class's package.
		return findBestNamespace(declaringClass);
	}

	/**
	 * Return the best namespace found for the given Field object.
	 * @param field
	 * @return namespace as a string.
	 * @throws ClassNotFoundException 
	 */
	private static String findBestNamespace(Field field) throws ClassNotFoundException {
		// First, see if the declaring class is already in the map (i.e. it is annotated with @XmlElement).
		Class declaringClass = field.getDeclaringClass();
		XmlRootElement rootElement = (XmlRootElement) declaringClass.getAnnotation(XmlRootElement.class);
		if(rootElement != null && rootElement.name() != null) {
			return elementNamespaceMap.get(rootElement.name() + "|");
		}

		// Next, look to see if the containing class has been annotated with @XmlType.
		XmlType xmlType = (XmlType) declaringClass.getAnnotation(XmlType.class);
		if(xmlType != null && !(xmlType.namespace().equals("##default"))) {
			return xmlType.namespace();
		}

		// Finally, look in the package-info.java file in the declaring class's package.
		return findBestNamespace(declaringClass);
	}

	/**
	 * Get the full package name of the given class.
	 * @param class The class to get the package name for.
	 * @return package name as a String
	 */
	private static String getPackageName(Class clazz) {
		String name = clazz.getName();
		return name.substring(0, name.lastIndexOf('.'));
	}

	/**
	 * Write the elementNamespaceMap to the location specified by {@code MAP_FILE}.
	 * @return The MAP_FILE with its new contents.
	 * @throws IOException
	 */
	private static File writeToFile() throws IOException {
		// Create a BufferedWriter for writing to the file.
		BufferedWriter writer = new BufferedWriter(new FileWriter(MAP_FILE));

		// Write the map to the file.
		for(String key : elementNamespaceMap.keySet()) {
			writer.write(key + "|" + elementNamespaceMap.get(key) + "\n");
		}

		writer.close();

		return MAP_FILE;
	}

	/**
	 * Run to generate ElementNamespaceMap.txt
	 * @throws ClassNotFoundException
	 * @throws IOException
	 */
	public static void main(String args[]) throws ClassNotFoundException, IOException {
		getElementNamespaceMap();
		writeToFile();
		System.out.println("Element-Namespace Map Generated.\n\nNOTE: Remember to copy the generated file to the following location in the sis-utility project:\n" +
				"src/main/resources/org/apache/sis/internal/jaxb\n");
	}

}
